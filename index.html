<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>METAR Dashboard ‚Äî Manual TAF/SYNOP</title>

  <style>
    :root{
      --bg:#001020;
      --panel:#0f2430;
      --card:rgba(0,0,40,0.92);
      --border:rgba(70,130,180,0.18);
      --text:#eef2f7;
      --muted:#9aa0a6;
      --accent:#55c1ff;
      --accent-strong:#1b7cff;
      --alert:#ff6b6b;
      --ok:#5dd18b;
      --radius:10px;
      --shadow:0 10px 30px rgba(0,0,0,0.45);
      --widget-width:260px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace;
      --dashboard-blue: #062a6f;
    }

    html,body{height:100%;margin:0;background:radial-gradient(1200px 600px at 10% -10%, rgba(123,97,255,0.04), transparent 60%), var(--bg);color:var(--text);font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial;-webkit-text-size-adjust:100%;}
    .page{width:100%;box-sizing:border-box;padding:12px 16px;display:flex;flex-direction:column;align-items:center;gap:12px;}
    .top-row{width:100%;max-width:1200px;display:flex;align-items:flex-start;justify-content:space-between;gap:12px;}
    .weather-widget{width:var(--widget-width);border-radius:var(--radius);background:var(--card);box-shadow:var(--shadow);border:1px solid var(--border);overflow:hidden;}
    .widget-head{padding:12px;display:flex;gap:8px;align-items:center;background:linear-gradient(90deg,var(--accent-strong),#7a5cff);}
    .widget-head .title{font-weight:700;font-size:14px;color:#fff;}
    .content{padding:12px;font-size:13px;color:var(--text);}
    .vis-wrap{display:flex;gap:8px;align-items:center;}
    .status-dot{width:10px;height:10px;border-radius:50%;background:var(--ok);box-shadow:0 0 0 2px rgba(93,209,139,0.12);}
    .status-dot.low{background:var(--alert);box-shadow:0 0 0 2px rgba(255,107,107,0.12);}
    .vis-value{font-weight:800;font-size:1.05rem;min-width:72px;text-align:left;}
    .timestamp{margin-top:6px;color:var(--muted);font-size:12px;display:block;}
    .btn-blue{padding:6px 10px;border-radius:8px;border:1px solid rgba(27,124,255,0.18);background:linear-gradient(180deg,var(--accent-strong),#2a9bff);color:#fff;cursor:pointer;font-weight:700;font-size:13px;box-shadow:0 6px 18px rgba(27,124,255,0.12);height:34px;display:inline-flex;align-items:center;gap:8px;}
    .btn-blue[disabled]{opacity:.6;cursor:not-allowed;}
    .header-block{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:6px;}
    .header-title{font-size:16px;color:var(--accent);font-weight:800;margin:0;}
    .header-clocks{display:flex;gap:18px;align-items:center;color:var(--muted);font-size:13px;}
    .clock-group{display:flex;flex-direction:column;align-items:center;gap:4px;}
    .clock-time{font-size:26px;color:var(--text);font-weight:800;letter-spacing:0.6px;}
    .clock-date{font-size:14px;color:var(--muted);}
    .controls-wrap{display:flex;gap:8px;align-items:center;}
    .controls-wrap button{padding:6px 8px;border-radius:8px;border:1px solid rgba(32,52,63,0.6);background:var(--panel);color:var(--accent);cursor:pointer;font-size:12px;height:34px;}
    .content-wrapper{width:100%;max-width:1200px;box-sizing:border-box;}
    .table-wrapper{width:100%;margin:10px 0;padding:0;box-sizing:border-box;}
    .section-controls{display:flex;justify-content:flex-end;gap:8px;margin-bottom:10px;align-items:center;}
    table{width:100%;border-collapse:collapse;font-family:var(--mono);color:var(--text);font-size:20px;}
    th,td{padding:10px 12px;border:2px solid rgba(32,52,63,0.6);text-align:center;vertical-align:middle;}
    th{background:#0c3146;color:var(--accent);font-weight:800;font-size:13px;text-transform:uppercase;}
    td.station{font-weight:900;color:var(--accent);font-size:20px;text-align:left;padding-left:16px;}
    tr.stale{opacity:.6;}
    td.alert{border:3px solid var(--alert) !important;}
    tr.raw td{background:#0b2a33;text-align:left;color:var(--muted);padding:12px;white-space:pre-wrap;font-size:14px;}
    .raw-current{font-size:14px;color:var(--text);display:block;white-space:pre-wrap;}
    .raw-past{margin-top:8px;font-size:15px;color:var(--text);display:block;font-weight:700;}
    .time-updated{background:var(--dashboard-blue) !important;color:#eaf6ff !important;font-weight:800;transition:background 0.6s, color 0.6s, opacity 0.6s;}
    .time-updated.dim{opacity:0.45 !important;}
    td.clouds.cloud-critical{border:3px solid var(--alert) !important;box-shadow:0 0 18px rgba(255,107,107,0.16) inset;background:rgba(255,107,107,0.03);}
    td.wx.wx-critical{border:3px solid var(--alert) !important;box-shadow:0 0 8px rgba(255,107,107,0.06) inset;}
    /* Make TAF and SYNOP fonts a bit bigger as requested */
    #taf-table, #synop-table { font-size: 16px; }
    #taf-table th, #synop-table th { font-size: 14px; padding:10px 12px; }
    #taf-table td, #synop-table td { font-size: 15px; padding:10px 12px; color:var(--muted); }
    .taf-raw, .synop-raw { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace; font-size:16px; color:var(--text); white-space:pre-wrap; word-break:break-word; }
    .footer{width:100%;max-width:1200px;margin-top:18px;color:var(--muted);font-size:13px;display:flex;align-items:center;justify-content:space-between;padding:12px 0;box-sizing:border-box;}
    .hidden-row{display:none !important;}
    /* small visual feedback for copy */
    .flash-blue{animation:flashBlue 600ms ease-in-out}
    @keyframes flashBlue{0%{background:rgba(27,124,255,0.12)}50%{background:rgba(27,124,255,0.22)}100%{background:transparent}}
    @media (max-width:920px){
      .top-row{flex-direction:column;align-items:stretch;gap:10px;}
      .weather-widget{width:100%;}
      table{font-size:18px;}
      .header-clocks{gap:10px;}
      #taf-table, #synop-table { font-size: 15px; }
      #taf-table td, #synop-table td { font-size: 14px; }
      .taf-raw, .synop-raw { font-size:15px; }
    }
  </style>
</head>
<body>
  <div class="page">
    <div class="top-row" role="banner">
      <div class="weather-widget" id="bonaire-vis-widget" title="Bonaire visibility" tabindex="0" aria-live="polite" role="region" aria-label="Bonaire visibility">
        <div class="widget-head">
          <div style="width:20px;height:20px;display:grid;place-items:center" aria-hidden="true">üëÅÔ∏è</div>
          <div class="title">Bonaire Visibility</div>
        </div>
        <div class="content">
          <div style="display:flex;align-items:center;justify-content:space-between">
            <div class="vis-wrap" aria-hidden="false">
              <div id="vis-status" class="status-dot" aria-hidden="true"></div>
              <div style="display:flex;flex-direction:column;align-items:flex-start">
                <div id="vis-value" class="vis-value" role="status" aria-live="polite">‚Äî</div>
                <div id="vis-timestamp" class="timestamp" aria-hidden="true" style="display:none"></div>
              </div>
            </div>
            <div style="display:flex;align-items:center;gap:8px">
              <button id="vis-refresh-btn" class="btn-blue" aria-label="Refresh Bonaire visibility">Refresh Vis</button>
            </div>
          </div>
        </div>
      </div>

      <div class="header-block" role="region" aria-label="Regional header">
        <div class="header-title">Regional Weather Centre</div>
        <div class="header-clocks" aria-hidden="false">
          <div class="clock-group" aria-label="Local time">
            <div style="font-size:12px;color:var(--muted)">Local</div>
            <div id="local-clock" class="clock-time">--:--:--</div>
            <div id="local-date" class="clock-date">--</div>
          </div>
          <div class="clock-group" aria-label="UTC time">
            <div style="font-size:12px;color:var(--muted)">UTC</div>
            <div id="utc-clock" class="clock-time">--:--:--</div>
            <div id="utc-date" class="clock-date">--</div>
          </div>
        </div>
      </div>

      <div class="controls-wrap" role="toolbar" aria-label="Controls">
        <button id="mute-btn" aria-pressed="false">Mute Beep</button>
        <button id="refresh-btn" class="btn-blue" title="Refresh METARs & Vis">Refresh METARs & Vis</button>
        <button id="test-btn">Enter Test Mode</button>
      </div>
    </div>

    <div class="content-wrapper">
      <div class="table-wrapper" id="metar-section">
        <div class="section-controls" aria-label="METAR controls">
          <button id="metar-refresh-btn" class="btn-blue" title="Refresh METAR section">Refresh METAR</button>
        </div>

        <table class="metar-table" aria-label="METAR list">
          <thead>
            <tr>
              <th>ICAO</th><th>Time</th><th>Wind</th><th>Vis</th><th>Wx</th><th>Clouds</th><th>Temp/Dew</th><th>QNH</th>
            </tr>
          </thead>
          <tbody id="metar"></tbody>
        </table>

        <div id="last-updated" style="text-align:center;color:var(--muted);margin-top:8px">METAR last updated: --:--</div>
      </div>

      <div class="table-wrapper">
        <div class="section-controls">
          <button id="taf-refresh-btn" class="btn-blue" title="Load TAFs manually">Load TAFs</button>
        </div>

        <table id="taf-table" aria-label="TAF list">
          <thead>
            <tr><th>ICAO</th><th>Raw TAF</th></tr>
          </thead>
          <tbody id="taf"></tbody>
        </table>

        <div id="taf-updated" style="text-align:center;color:var(--muted);margin-top:8px">TAF last updated: --:--</div>
      </div>

      <div class="table-wrapper">
        <div class="section-controls">
          <button id="synop-refresh-btn" class="btn-blue" title="Load SYNOPs manually">Load SYNOPs</button>
        </div>

        <table id="synop-table" aria-label="SYNOP list">
          <thead>
            <tr><th>Source</th><th>Raw SYNOP</th></tr>
          </thead>
          <tbody id="synop"></tbody>
        </table>

        <div id="synop-updated" style="text-align:center;color:var(--muted);margin-top:8px">SYNOP last updated: --:--</div>
      </div>
    </div>

    <div class="footer" role="contentinfo" aria-label="Footer">
      <div>Created by GNIUS</div>
      <div style="color:var(--muted)">Bonaire visibility is taken directly from KNMI Bonaire Current page</div>
    </div>
  </div>

  <script>
    (function () {
      'use strict';

      /* Configuration */
      const STATIONS = ['TNCA','TNCB','TNCC','TNCM','SVMI','SVVA'];
      const METAR_TEMPLATE = 'https://tgftp.nws.noaa.gov/data/observations/metar/stations/{ICAO}.TXT';
      const TAF_TEMPLATE = 'https://tgftp.nws.noaa.gov/data/forecasts/taf/stations/{ICAO}.TXT';
      const KNMI_BONAIRE_URL = 'https://www.knmidc.org/weather/bonaire/?Current';
      const METAR_REFRESH_MS = 30 * 1000;
      const VIS_REFRESH_MS = 60 * 1000;
      const REQUEST_TIMEOUT_MS = 12000;
      const FALLBACKS = [
        { name:'allorigins_json', prefix:'https://api.allorigins.win/get?url=' },
        { name:'jina_raw', prefix:'https://r.jina.ai/http://' }
      ];
      const MAX_RETRIES = 3;
      const BACKOFF_BASE_MS = 500;

      /* DOM refs */
      const metarTbody = document.getElementById('metar');
      const tafTbody = document.getElementById('taf');
      const synopTbody = document.getElementById('synop');
      const lastUpdatedEl = document.getElementById('last-updated');
      const tafUpdatedEl = document.getElementById('taf-updated');
      const synopUpdatedEl = document.getElementById('synop-updated');
      const visValueEl = document.getElementById('vis-value');
      const visStatusEl = document.getElementById('vis-status');
      const visTsEl = document.getElementById('vis-timestamp');

      /* State */
      let mute = false;
      let testMode = false;
      const metarState = {}; // per station: { lastTime, lastRaw, pastRaw, row, rawEl, pastEl, highlightTimeout, stats:{winds:[],temps:[],vis:[],wxSummary:''} }

      /* Utilities */
      function pad(n){ return n < 10 ? '0' + n : '' + n; }
      function formatLocalDateTimeParts(){ const d = new Date(); return { date: `${pad(d.getDate())}-${pad(d.getMonth()+1)}-${d.getFullYear()}`, time: `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}` }; }
      function formatUTCDateTimeParts(){ const d = new Date(); return { date: `${pad(d.getUTCDate())}-${pad(d.getUTCMonth()+1)}-${d.getUTCFullYear()}`, time: `${pad(d.getUTCHours())}:${pad(d.getUTCMinutes())}:${pad(d.getUTCSeconds())}` }; }
      function tickClocks(){ try{ const local = formatLocalDateTimeParts(); const utc = formatUTCDateTimeParts(); document.getElementById('local-clock').textContent = local.time; document.getElementById('local-date').textContent = local.date; document.getElementById('utc-clock').textContent = utc.time; document.getElementById('utc-date').textContent = utc.date; }catch(e){} }
      tickClocks(); setInterval(tickClocks, 1000);

      /* Audio: beep for new METAR, distinct alarm for critical conditions (TNCA gust >=35kt or TS/TSRA) */
      function playBeep(){ if(mute) return; try{ const ctx = new (window.AudioContext || window.webkitAudioContext)(); const o = ctx.createOscillator(); const g = ctx.createGain(); o.type='sine'; o.frequency.value=880; g.gain.value=0.02; o.connect(g); g.connect(ctx.destination); o.start(); setTimeout(()=>{ o.stop(); ctx.close(); },120); }catch(e){} }

      // Distinct alarm: two-tone short pattern (used for TNCA gust >=35kt or TS/TSRA)
      function playCriticalAlarm(){ if(mute) return; try{ const ctx = new (window.AudioContext || window.webkitAudioContext)(); const now = ctx.currentTime; const g = ctx.createGain(); g.gain.value = 0.06; g.connect(ctx.destination);

          const o1 = ctx.createOscillator(); o1.type = 'sawtooth';
          const o2 = ctx.createOscillator(); o2.type = 'sine';

          o1.frequency.setValueAtTime(520, now);
          o2.frequency.setValueAtTime(780, now);

          o1.connect(g); o2.connect(g);

          o1.start(now); o2.start(now);

          // quick rise then fall pattern
          o1.frequency.exponentialRampToValueAtTime(880, now + 0.12);
          o2.frequency.exponentialRampToValueAtTime(1200, now + 0.12);

          setTimeout(() => {
            o1.frequency.exponentialRampToValueAtTime(520, ctx.currentTime + 0.02);
            o2.frequency.exponentialRampToValueAtTime(780, ctx.currentTime + 0.02);
          }, 140);

          setTimeout(() => {
            // second short pulse
            const t = ctx.currentTime;
            o1.frequency.setValueAtTime(600, t);
            o2.frequency.setValueAtTime(900, t);
            o1.frequency.exponentialRampToValueAtTime(1000, t + 0.08);
            o2.frequency.exponentialRampToValueAtTime(1400, t + 0.08);
          }, 220);

          setTimeout(()=>{ o1.stop(); o2.stop(); ctx.close(); }, 700);
        }catch(e){} }

      /* Fetch helpers */
      async function fetchWithTimeout(url, timeout = REQUEST_TIMEOUT_MS, opts = {}) {
        const ctrl = new AbortController();
        const id = setTimeout(() => ctrl.abort(), timeout);
        try {
          const r = await fetch(url, Object.assign({ cache: 'no-store', mode: 'cors', signal: ctrl.signal }, opts));
          clearTimeout(id);
          return r;
        } catch (e) {
          clearTimeout(id);
          throw e;
        }
      }

      async function robustFetchText(url){
        // 1) direct attempt
        try {
          const r = await fetchWithTimeout(url, REQUEST_TIMEOUT_MS);
          if (r && r.ok) {
            const txt = await r.text();
            if (txt && txt.trim()) return { ok:true, text: txt.trim() };
          }
        } catch(e){ /* continue to proxies */ }

        // 2) allorigins JSON wrapper
        try {
          const proxy = FALLBACKS[0].prefix + encodeURIComponent(url);
          const r = await fetchWithTimeout(proxy, REQUEST_TIMEOUT_MS);
          if (r && r.ok) {
            const j = await r.json();
            if (j && typeof j.contents === 'string' && j.contents.trim()) return { ok:true, text: j.contents.trim() };
          }
        } catch(e){ /* continue */ }

        // 3) jina.ai raw (path-style)
        try {
          const proxy2 = FALLBACKS[1].prefix + url.replace(/^https?:\/\//,'');
          const r2 = await fetchWithTimeout(proxy2, REQUEST_TIMEOUT_MS * 2);
          if (r2 && r2.ok) {
            const txt2 = await r2.text();
            if (txt2 && txt2.trim()) return { ok:true, text: txt2.trim() };
          }
        } catch(e){ /* continue */ }

        return { ok:false, error:'no content' };
      }

      async function fetchWithRetries(url, attempts = MAX_RETRIES){
        let lastErr = null;
        for (let i = 0; i < attempts; i++){
          try {
            const out = await robustFetchText(url);
            if (out && out.ok && out.text) return out;
            lastErr = out && out.error ? new Error(out.error) : new Error('No content');
          } catch (err) {
            lastErr = err;
          }
          const backoff = BACKOFF_BASE_MS * Math.pow(2, i);
          const jitter = Math.floor(Math.random() * Math.min(500, backoff));
          await new Promise(r => setTimeout(r, backoff + jitter));
        }
        return { ok:false, error: lastErr ? String(lastErr) : 'fetch failed' };
      }

      /* KNMI Bonaire visibility extraction */
      function extractKnmiBonaireVisibility(text){
        if(!text || !text.trim()) return null;
        const s = String(text).replace(/\u00A0/g,' ').replace(/\s+/g,' ');
        let m = s.match(/Visibility\s*\(?m\)?\)?[^\d]{0,30}([0-9]{3,6})\b/i);
        if (m && m[1]) return `${m[1]} m`;
        m = s.match(/Visibiliteit\s*\(?m\)?[^\d]{0,30}([0-9]{3,6})\b/i);
        if (m && m[1]) return `${m[1]} m`;
        m = s.match(/Zicht(?:baarheid)?\s*\(?m\)?[^\d]{0,30}([0-9]{3,6})\b/i);
        if (m && m[1]) return `${m[1]} m`;
        m = s.match(/\b([0-9]{3,6})\s?(?:m|meter|meters)\b/i);
        if (m && m[1]) return `${m[1]} m`;
        const allNums = Array.from(s.matchAll(/\b([0-9]{4,6})\b/g)).map(a=>a[1]);
        if (allNums.length){
          allNums.sort((a,b)=> b.length - a.length || a.localeCompare(b));
          return `${allNums[0]} m`;
        }
        return null;
      }

      async function updateVisFromKnmi(){
        try {
          const out = await fetchWithRetries(KNMI_BONAIRE_URL, MAX_RETRIES);
          if (!out || !out.ok || !out.text) {
            visValueEl.textContent = '‚Äî';
            visStatusEl.classList.remove('low');
            visTsEl.style.display = 'none';
            return;
          }
          const text = String(out.text || '');
          const rawVis = extractKnmiBonaireVisibility(text);
          if (rawVis) {
            visValueEl.textContent = rawVis;
            const numeric = rawVis.match(/([0-9]{3,6})/);
            if (numeric) {
              const meters = parseInt(numeric[1].replace(/\D/g,''),10);
              visStatusEl.classList.toggle('low', meters < 20000);
            } else {
              visStatusEl.classList.remove('low');
            }
            const local = formatLocalDateTimeParts();
            if (visTsEl) { visTsEl.textContent = `Updated: ${local.date} ${local.time}`; visTsEl.style.display = 'block'; }
          } else {
            visValueEl.textContent = '‚Äî';
            visStatusEl.classList.remove('low');
            visTsEl.textContent = 'Visibility not found in KNMI response';
            visTsEl.style.display = 'block';
          }
        } catch (e) {
          console.error('updateVisFromKnmi error', e);
          visValueEl.textContent = '‚Äî';
          visStatusEl.classList.remove('low');
          visTsEl.style.display = 'none';
        }
      }

      /* Parsing helpers */
      function cleanForParse(s){ if(!s) return ''; return String(s).replace(/\sRMK[\s\S]*/i,'').replace(/\s(?:TEMPO|BECMG|PROB\d{2}|FM\d{6})[\s\S]*/i,'').replace(/\bAUTO\b|\bCOR\b/gi,'').trim(); }

      /**
       * parseMetar
       * returns: { time, wind, windBase, vis, visTokens, visMin, wx, cld, td, qnh, gust, age, raw }
       */
      function parseMetar(raw){
        const cleaned = cleanForParse(raw);
        const tokens = cleaned.split(/\s+/);
        const time = tokens[1] || '--';
        const windBase = tokens.find(x=>/^(?:VRB|\d{3})\d{2}(?:G\d{2,3})?KT$/.test(x)) || '/////KT';
        const varDir = tokens.find(x=>/^\d{3}V\d{3}$/.test(x));
        const wind = varDir ? `${windBase} ${varDir}` : windBase;
        const visTokens = tokens.filter(x=>/^\d{4}(?:[NSEW]{1,2})?$/.test(x));
        const vis = visTokens.length ? visTokens.join(' ') : '--';
        const visMin = visTokens.length ? Math.min(...visTokens.map(v=>parseInt(v,10)).filter(n=>!isNaN(n))) : NaN;
        const wx = tokens.filter(x=>/^(?:\+|-)?(?:VC)?(?:TS|VCTS|VCSH|TSRA|VCTS|VCSH|SH|SHRA|RA|DZ|SN|FG|BR|HZ|SQ|PO)/.test(x)).join(' ') || '--';
        const cldMatch = cleaned.match(/((?:FEW|SCT|BKN|OVC)(?:\d{3}|\/{3})(?:TCU|CB)?)/gi) || [];
        const cld = cldMatch.join(' ') || '--';
        const td = tokens.find(x=>/^M?\d{2}\/M?\d{2}$/.test(x)) || '--';
        const qp = tokens.find(x=>/^Q\d{4}$/.test(x)) || null;
        let qnh = '‚Äî';
        if(qp){ const h = qp.slice(1); const inches = (parseInt(h,10) * 0.029529983071445).toFixed(2); qnh = `${h} - ${inches}`; }
        const gust = +(windBase.match(/G(\d{2,3})/)?.[1] || 0);
        let age = 0;
        if(/^\d{6}Z$/.test(time)){ const now=new Date(); const dd=parseInt(time.slice(0,2),10); const hh=parseInt(time.slice(2,4),10); const mm=parseInt(time.slice(4,6),10); const tokenUtc = Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), dd, hh, mm); age = (Date.now() - tokenUtc) / 60000; }
        return { time, wind, windBase, vis, visTokens, visMin, wx, cld, td, qnh, gust, age, raw: cleaned };
      }

      function setWxCritical(cell, wxText){
        if(!cell) return false;
        const txt = String(wxText || '');
        const hasTS = /\b(?:VCTS|VCSH|TS|TSRA)\b/i.test(txt);
        const hasSHRA = /\bSHRA\b/i.test(txt);
        const hasSevere = /(^|\s)(?:\+|-)\s*(?:SHRA|SH|RA|DZ|SN|FG|BR|HZ)/i.test(txt);
        const hasVCwithSH = /\bVC(?:SH|TS)\b/i.test(txt);
        const critical = hasTS || hasVCwithSH || hasSevere || hasSHRA;
        if(critical) cell.classList.add('wx-critical'); else cell.classList.remove('wx-critical');
        return critical;
      }

      function isCloudGroupWithCbTcu(cloudString){
        if(!cloudString) return false;
        return /(?:FEW|SCT|BKN|OVC)\d{3}(?:CB|TCU)/i.test(cloudString);
      }

      /* Build METAR table */
      function buildMetarTable(){
        metarTbody.innerHTML = '';
        STATIONS.forEach(icao => {
          metarState[icao] = metarState[icao] || { lastTime:null, lastRaw:null, pastRaw:null, row:null, rawEl:null, pastEl:null, highlightTimeout:null, stats:{winds:[],temps:[],vis:[],wxSummary:''} };
          const tr = document.createElement('tr');
          const rr = document.createElement('tr');
          rr.className = 'raw';
          tr.innerHTML = `<td class="station">${icao}</td><td class="time">--</td><td class="wind">--</td><td>--</td><td>--</td><td class="clouds">--</td><td>--</td><td>--</td>`;
          rr.innerHTML = `<td colspan="8"><span class="raw-current"></span><span class="raw-past" style="display:block;margin-top:8px;color:var(--text);font-size:15px;font-weight:700"></span></td>`;
          metarTbody.appendChild(tr);
          metarTbody.appendChild(rr);
          metarState[icao].row = tr;
          metarState[icao].rawEl = rr.querySelector('.raw-current');
          metarState[icao].pastEl = rr.querySelector('.raw-past');
        });
      }
      buildMetarTable();

      /* Highlight time cell blue only when new data arrives, fade after 5 minutes */
      function markTimeUpdated(icao){
        const state = metarState[icao];
        if(!state || !state.row) return;
        const timeCell = state.row.querySelector('td.time');
        if(!timeCell) return;
        if (state.highlightTimeout) {
          clearTimeout(state.highlightTimeout);
          state.highlightTimeout = null;
        }
        timeCell.classList.add('time-updated');
        timeCell.classList.remove('dim');
        // fade after 5 minutes, then remove classes
        state.highlightTimeout = setTimeout(() => {
          timeCell.classList.add('dim');
          setTimeout(() => {
            timeCell.classList.remove('time-updated');
            timeCell.classList.remove('dim');
            state.highlightTimeout = null;
          }, 700);
        }, 5 * 60 * 1000);
      }

      function extractWindSpeedFromWindBase(windBase){
        if(!windBase || typeof windBase !== 'string') return 0;
        const m = windBase.match(/^(?:VRB|(\d{3}))(\d{2,3})(?:G(\d{2,3}))?KT$/i);
        if(!m) return 0;
        const speed = parseInt(m[2],10);
        return isNaN(speed) ? 0 : speed;
      }

      /* Render METAR into table
         - Beep on new METAR data (time token changed)
         - Play distinct critical alarm when new data AND (TNCA gust >= 35 kt OR TS/TSRA present)
         - Wind-with-gust highlights only the wind cell for that station (on new data)
      */
      function renderMetar(icao, raw){
        try{
          if(!raw) return false;
          const lines = String(raw).split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
          let metarLine = null;
          for (const ln of lines){
            if (ln.startsWith(icao) || /\b\d{6}Z\b/.test(ln) || /^[A-Z]{4}\s+\d{6}Z/.test(ln)){ metarLine = ln; break; }
          }
          if (!metarLine && lines.length) metarLine = lines[lines.length - 1];
          if (!metarLine) return false;
          const parsed = parseMetar(metarLine);
          const state = metarState[icao];
          if(!state || !state.row) return false;
          const tds = state.row.querySelectorAll('td');

          // clear previous flags for this row (only row-local)
          [2,3,4,5].forEach(i=>{ tds[i].classList.remove('alert'); tds[i].classList.remove('cloud-critical'); tds[i].classList.remove('wx-critical'); });

          state.row.classList.toggle('stale', parsed.age > 120);
          if(state.lastRaw && state.lastRaw !== metarLine) state.pastRaw = state.lastRaw;
          state.lastRaw = metarLine;

          // preserve previous time to detect new data
          const previousTime = state.lastTime;
          state.lastTime = parsed.time;
          const isNew = previousTime !== parsed.time;

          // display fields
          let timeDisplay = '--';
          if(parsed.time && typeof parsed.time === 'string'){
            const m6 = parsed.time.match(/^(\d{2})(\d{2})(\d{2})Z$/);
            const m4 = parsed.time.match(/^(\d{2})(\d{2})Z$/);
            if(m6) timeDisplay = `${m6[2]}:${m6[3]}Z`;
            else if(m4) timeDisplay = `${m4[1]}:${m4[2]}Z`;
            else timeDisplay = parsed.time;
          }
          tds[1].textContent = timeDisplay;
          tds[2].textContent = parsed.wind;
          tds[3].textContent = parsed.vis;
          tds[4].textContent = parsed.wx;
          tds[5].textContent = parsed.cld;
          tds[6].textContent = parsed.td;
          tds[7].textContent = parsed.qnh;
          if(state.rawEl) state.rawEl.textContent = state.lastRaw || '';
          if(state.pastEl){
            if(state.pastRaw){ state.pastEl.style.display = 'block'; state.pastEl.textContent = `Previous: ${state.pastRaw}`; }
            else { state.pastEl.style.display = 'none'; state.pastEl.textContent = ''; }
          }

          // detect conditions
          const hasGustToken = /G\d{2,3}KT/i.test(parsed.windBase);
          const gustValue = parsed.gust || 0;
          const windSpeed = extractWindSpeedFromWindBase(parsed.windBase);
          const windHasGust = hasGustToken || gustValue > 0;

          const tsPresent = /\b(?:VCTS|VCSH|TS|TSRA)\b/i.test(parsed.wx);
          const cloudFlag = isCloudGroupWithCbTcu(parsed.cld);
          const wxCritical = setWxCritical(tds[4], parsed.wx);

          // Only beep when new data arrives
          if (isNew) {
            // Play simple beep for any new METAR
            playBeep();
            // highlight time cell (blue) only when new data
            markTimeUpdated(icao);
          }

          // Wind-with-gust: highlight only the wind cell for that station (only when new)
          if (windHasGust && isNew) {
            tds[2].classList.add('alert');
          }

          // Keep other condition highlights (visibility, wx, clouds) but they do not trigger global beep/alarm
          if(!isNaN(parsed.visMin) && parsed.visMin <= 5000) tds[3].classList.add('alert');
          if(wxCritical) tds[4].classList.add('alert');
          if(cloudFlag) {
            tds[5].classList.add('cloud-critical');
          }

          // CRITICAL ALARM logic:
          // When new data AND (TNCA gust >= 35 kt OR TS/TSRA present anywhere), play distinct critical alarm.
          const criticalForThisStation = (icao === 'TNCA' && gustValue >= 35);
          const criticalGlobal = tsPresent;
          if (isNew && (criticalForThisStation || criticalGlobal)) {
            playCriticalAlarm();
          }

          // update small per-station arrays for internal use (no summary UI)
          if (typeof windSpeed === 'number') {
            state.stats.winds.push(windSpeed);
            if (state.stats.winds.length > 200) state.stats.winds.shift();
          }
          if (parsed.td && typeof parsed.td === 'string') {
            const m = parsed.td.match(/^(M?)(\d{1,2})\/(M?)(\d{1,2})$/);
            if (m) {
              const sign = m[1] === 'M' ? -1 : 1;
              const tempVal = sign * parseInt(m[2],10);
              state.stats.temps.push(tempVal);
              if (state.stats.temps.length > 200) state.stats.temps.shift();
            }
          }
          if (!isNaN(parsed.visMin)) {
            state.stats.vis.push(parsed.visMin);
            if (state.stats.vis.length > 200) state.stats.vis.shift();
          }

          return true;
        }catch(e){ console.error('renderMetar error', icao, e); return false; }
      }

      /* Fetch METAR for a station and render */
      async function fetchMetarFor(icao){
        try {
          const url = METAR_TEMPLATE.replace('{ICAO}', icao);
          const out = await fetchWithRetries(url, MAX_RETRIES);
          if (!out || !out.ok || !out.text) return false;
          const txt = String(out.text).trim();
          const lines = txt.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
          for (let i = lines.length - 1; i >= 0; i--){
            const ln = lines[i];
            if (ln.startsWith(icao) || /\b\d{6}Z\b/.test(ln) || /^[A-Z]{4}\s+\d{6}Z/.test(ln)){
              if ((icao === 'SVMI' || icao === 'SVVA') && /\bAUTO\b/i.test(ln)) continue;
              renderMetar(icao, ln);
              return true;
            }
          }
          return false;
        } catch (err) {
          console.error('METAR fetch error for', icao, err);
          return false;
        }
      }

      /* Refresh all METARs and update last-updated */
      async function refreshAllMetars(){
        try {
          const promises = STATIONS.map(s => fetchMetarFor(s));
          const results = await Promise.all(promises);
          const anyLoaded = results.some(Boolean);

          const local = (function(){ const d=new Date(); return `${pad(d.getDate())}-${pad(d.getMonth()+1)}-${d.getFullYear()} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}` })();
          if (lastUpdatedEl) lastUpdatedEl.textContent = `METAR last updated: ${local}`;

          // Beeps and critical alarms are handled per-station in renderMetar when new data arrives.
          return anyLoaded;
        } catch (e) { console.error('refreshAllMetars error', e); return false; }
      }

      /* TAF & SYNOP helpers (sanitized display) */
      function sanitizeTextForDisplay(text){
        if(!text) return '';
        const lines = String(text).split('\n').map(l=>l.trim()).filter(Boolean);
        const keep = [];
        for(const line of lines){
          if (/^\s*URL\s*Source\s*:/i.test(line)) continue;
          if (/^\s*Published\s*Time\s*:/i.test(line)) continue;
          if (/^\s*Markdown\s*Content\s*:/i.test(line)) continue;
          if (/^https?:\/\//i.test(line)) continue;
          keep.push(line);
        }
        return keep.join('\n');
      }

      function buildTafTable(){
        tafTbody.innerHTML = '';
        STATIONS.slice(0,3).forEach(icao => {
          const tr = document.createElement('tr');
          tr.dataset.icao = icao;
          tr.innerHTML = `<td class="station">${icao}</td><td class="taf-raw"></td>`;
          tafTbody.appendChild(tr);
        });
      }
      buildTafTable();

      async function loadTafRow(icao){
        try {
          const url = TAF_TEMPLATE.replace('{ICAO}', icao);
          const out = await fetchWithRetries(url, MAX_RETRIES);
          if (out && out.ok && out.text){
            const row = tafTbody.querySelector(`tr[data-icao="${icao}"]`);
            if (row) row.querySelector('.taf-raw').textContent = sanitizeTextForDisplay(out.text);
            const local = formatLocalDateTimeParts();
            if (tafUpdatedEl) tafUpdatedEl.textContent = `TAF last updated: ${local.date} ${local.time}`;
          }
        } catch (e){ console.error('loadTafRow error', icao, e); }
      }

      async function loadAllTafs(){
        const list = STATIONS.slice(0,3);
        await Promise.all(list.map(i => loadTafRow(i)));
      }

      function buildSynopTable(){
        synopTbody.innerHTML = '';
        const sources = ['TNCA SINU50','TNCA SMNU50','TNCC SI','TNCC SM'];
        sources.forEach((name, i) => {
          const tr = document.createElement('tr');
          tr.dataset.idx = String(i);
          tr.innerHTML = `<td class="station">${name}</td><td class="synop-raw"></td>`;
          synopTbody.appendChild(tr);
        });
      }
      buildSynopTable();

      async function loadSynopRow(index, url){
        try {
          const out = await fetchWithRetries(url, MAX_RETRIES);
          if (out && out.ok && out.text){
            const row = synopTbody.querySelector(`tr[data-idx="${index}"]`);
            if (row) row.querySelector('.synop-raw').textContent = sanitizeTextForDisplay(out.text);
            const local = formatLocalDateTimeParts();
            if (synopUpdatedEl) synopUpdatedEl.textContent = `SYNOP last updated: ${local.date} ${local.time}`;
          }
        } catch (e){ console.error('loadSynopRow error', index, e); }
      }

      async function loadAllSynops(){
        const SYNOP_URLS = [
          'https://tgftp.nws.noaa.gov/data/raw/si/sinu50.tnca..txt',
          'https://tgftp.nws.noaa.gov/data/raw/sm/smnu50.tnca..txt',
          'https://tgftp.nws.noaa.gov/data/raw/si/sica20.tncc..txt',
          'https://tgftp.nws.noaa.gov/data/raw/sm/smca01.tncc..txt'
        ];
        const promises = SYNOP_URLS.map((u, i) => loadSynopRow(i, u));
        await Promise.all(promises);
      }

      /* Test mode runner (samples include FEW013CB and FEW016TCU) */
      let testInterval = null;
      const TEST_SAMPLES = [
        {
          'TNCA':'TNCA 152000Z 35035G50KT 9999 VCSH FEW013CB 28/23 Q1011 NOSIG',
          'TNCB':'TNCB 152000Z 34020G35KT 0400 +TSRA FEW020CB BKN030 26/24 Q0980',
          'TNCC':'TNCC 152000Z 12045G60KT 0500 +TSRA FEW016TCU OVC025 27/25 Q1000',
          'TNCM':'TNCM 152000Z 20015G35KT 0800 SHRA FEW020TCU BKN018 25/23 Q0995',
          'SVMI':'SVMI 152000Z 30025G45KT 9999 VCSH FEW020CB BKN030 28/26 Q1002',
          'SVVA':'SVVA 152000Z 04010G20KT 0300 -SHRA FEW020 BKN025 22/21 Q1008'
        },
        {
          'TNCA':'TNCA 152010Z 35020G40KT 0400 +TSRA FEW020CB BKN030 26/24 Q0980',
          'TNCB':'TNCB 152010Z 09012G30KT 0500 -DZ SCT020 BKN040 24/22 Q1010',
          'TNCC':'TNCC 152010Z 12045G60KT 0500 VCTS FEW020CB OVC025 27/25 Q1000',
          'TNCM':'TNCM 152010Z 20015G35KT 0800 SHRA FEW020TCU BKN018 25/23 Q0995',
          'SVMI':'SVMI 152010Z 30025G45KT 9999 VCTS FEW020CB BKN030 28/26 Q1002',
          'SVVA':'SVVA 152010Z 04010G20KT 0300 -SHRA FEW020 BKN025 22/21 Q1008'
        },
        {
          'TNCA':'TNCA 152020Z 12010KT 9999 FEW020 SCT040 28/24 Q1013',
          'TNCB':'TNCB 152020Z 08008KT 9999 FEW025 SCT050 26/22 Q1015',
          'TNCC':'TNCC 152020Z 14012KT 9999 SCT030 BKN050 27/25 Q1008',
          'TNCM':'TNCM 152020Z 18012KT 9999 FEW020 SCT040 26/24 Q1005',
          'SVMI':'SVMI 152020Z 20015KT 9999 FEW020 SCT030 29/27 Q1009',
          'SVVA':'SVVA 152020Z 06008KT 9999 FEW020 SCT040 24/22 Q1010'
        }
      ];

      function applyTestSamples(sample){
        STATIONS.forEach(icao => {
          const raw = sample[icao] || `${icao} 151206Z 09010KT 9999 FEW020 28/24 Q1013`;
          renderMetar(icao, raw);
        });
        const local = formatLocalDateTimeParts();
        if (lastUpdatedEl) lastUpdatedEl.textContent = `METAR test data applied: ${local.date} ${local.time}`;
      }

      function startTestRunner(){
        if(testInterval) clearInterval(testInterval);
        let idx = 0;
        applyTestSamples(TEST_SAMPLES[idx]);
        testInterval = setInterval(()=>{ idx = (idx + 1) % TEST_SAMPLES.length; applyTestSamples(TEST_SAMPLES[idx]); }, 4000);
      }

      function stopTestRunner(){
        if(testInterval){ clearInterval(testInterval); testInterval = null; }
      }

      /* Wiring events */
      document.getElementById('metar-refresh-btn')?.addEventListener('click', () => refreshAllMetars());
      document.getElementById('refresh-btn')?.addEventListener('click', () => { updateVisFromKnmi(); refreshAllMetars(); });
      document.getElementById('taf-refresh-btn')?.addEventListener('click', async () => { const btn = document.getElementById('taf-refresh-btn'); btn.disabled = true; try { await loadAllTafs(); } catch(e){} setTimeout(()=>btn.disabled = false, 800); });
      document.getElementById('synop-refresh-btn')?.addEventListener('click', async () => { const btn = document.getElementById('synop-refresh-btn'); btn.disabled = true; try { await loadAllSynops(); } catch(e){} setTimeout(()=>btn.disabled = false, 800); });
      document.getElementById('vis-refresh-btn')?.addEventListener('click', async () => { const btn = document.getElementById('vis-refresh-btn'); btn.disabled = true; try { await updateVisFromKnmi(); } catch(e){} setTimeout(()=>btn.disabled = false, 800); });

      document.getElementById('mute-btn')?.addEventListener('click', () => {
        const b = document.getElementById('mute-btn');
        mute = !mute;
        b.setAttribute('aria-pressed', String(mute));
        b.textContent = mute ? 'Unmute Beep' : 'Mute Beep';
      });

      document.getElementById('test-btn')?.addEventListener('click', () => {
        testMode = !testMode;
        const b = document.getElementById('test-btn');
        if (b) b.textContent = testMode ? 'Exit Test Mode' : 'Enter Test Mode';
        if (testMode) startTestRunner(); else stopTestRunner();
      });

      // single-click copy to clipboard ONLY for cells inside the METAR table body (#metar),
      // and only for the regular data rows (not the following raw rows which have class "raw").
      document.getElementById('metar')?.addEventListener('click', async e => {
        const td = e.target.closest('td');
        if(!td) return;
        // find the row containing this cell
        const tr = td.closest('tr');
        if(!tr) return;
        // do not copy from raw rows (they have class "raw")
        if (tr.classList && tr.classList.contains('raw')) return;
        // ensure the clicked cell is inside the metar tbody (it is, because listener attached),
        // and avoid copying from header (headers are in thead, not tbody)
        const text = td.textContent.trim();
        if (!text) return;

        try {
          await navigator.clipboard.writeText(text);
          td.classList.add('flash-blue');
          setTimeout(()=>td.classList.remove('flash-blue'),600);
          const sel = window.getSelection && window.getSelection();
          if(sel && sel.removeAllRanges) sel.removeAllRanges();
        } catch (err) {
          // fallback: try execCommand (older browsers)
          try {
            const ta = document.createElement('textarea');
            ta.value = text;
            ta.style.position = 'fixed';
            ta.style.left = '-9999px';
            document.body.appendChild(ta);
            ta.select();
            document.execCommand('copy');
            document.body.removeChild(ta);
            td.classList.add('flash-blue');
            setTimeout(()=>td.classList.remove('flash-blue'),600);
          } catch (e) {
            // silent fail
            console.warn('copy failed', e);
          }
        }
      });

      /* Intervals & init */
      setInterval(()=>{ if(!testMode) refreshAllMetars(); }, METAR_REFRESH_MS);
      setInterval(()=>{ if(!testMode) updateVisFromKnmi(); }, VIS_REFRESH_MS);

      (async function init(){
        try {
          buildMetarTable();
          buildTafTable();
          buildSynopTable();

          // Load only METARs and visibility automatically.
          await Promise.allSettled([
            updateVisFromKnmi(),
            refreshAllMetars()
          ]);

          // If no METAR data loaded (likely CORS/network), auto-start test mode so UI is usable.
          const anyData = STATIONS.some(icao => metarState[icao] && metarState[icao].lastRaw);
          if (!anyData) {
            console.warn('No live METAR data loaded ‚Äî starting Test Mode fallback so UI is visible.');
            testMode = true;
            startTestRunner();
            const b = document.getElementById('test-btn'); if (b) b.textContent = 'Exit Test Mode';
          }
        } catch (e) {
          console.error('initialization error', e);
          testMode = true;
          startTestRunner();
          const b = document.getElementById('test-btn'); if (b) b.textContent = 'Exit Test Mode';
        }
      })();

      // Expose debug API
      window.__metarDashboard = { refreshAllMetars, updateVisFromKnmi, loadAllTafs, loadAllSynops, loadTafRow, loadSynopRow, renderMetar, startTestRunner, stopTestRunner, metarState };

    })();
  </script>
</body>
</html>
